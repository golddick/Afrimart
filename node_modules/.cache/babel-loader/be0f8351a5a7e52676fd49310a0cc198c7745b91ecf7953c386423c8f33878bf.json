{"ast":null,"code":"import { E as getDefaultExportFromCjs } from './dep-df561101.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-c423598f.js';\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\n\nconst __filename = __cjs_fileURLToPath(import.meta.url);\n\nconst __dirname = __cjs_dirname(__filename);\n\nconst require = __cjs_createRequire(import.meta.url);\n\nconst __require = require;\n\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n\n    if (typeof e !== 'string' && !Array.isArray(e)) {\n      for (var k in e) {\n        if (k !== 'default' && !(k in n)) {\n          n[k] = e[k];\n        }\n      }\n    }\n  }\n\n  return n;\n}\n\nconst startsWithKeywordRegexp = /^(all|not|only|print|screen)/i;\n\nvar joinMedia$1 = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia;\n  if (parentMedia.length && !childMedia.length) return parentMedia;\n  if (!parentMedia.length && !childMedia.length) return [];\n  const media = [];\n  parentMedia.forEach(parentItem => {\n    const parentItemStartsWithKeyword = startsWithKeywordRegexp.test(parentItem);\n    childMedia.forEach(childItem => {\n      const childItemStartsWithKeyword = startsWithKeywordRegexp.test(childItem);\n\n      if (parentItem !== childItem) {\n        if (childItemStartsWithKeyword && !parentItemStartsWithKeyword) {\n          media.push(`${childItem} and ${parentItem}`);\n        } else {\n          media.push(`${parentItem} and ${childItem}`);\n        }\n      }\n    });\n  });\n  return media;\n};\n\nvar joinLayer$1 = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer;\n  if (parentLayer.length && !childLayer.length) return parentLayer;\n  if (!parentLayer.length && !childLayer.length) return [];\n  return parentLayer.concat(childLayer);\n};\n\nvar readCache$1 = {\n  exports: {}\n};\nvar pify$2 = {\n  exports: {}\n};\n\nvar processFn = function (fn, P, opts) {\n  return function () {\n    var that = this;\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return new P(function (resolve, reject) {\n      args.push(function (err, result) {\n        if (err) {\n          reject(err);\n        } else if (opts.multiArgs) {\n          var results = new Array(arguments.length - 1);\n\n          for (var i = 1; i < arguments.length; i++) {\n            results[i - 1] = arguments[i];\n          }\n\n          resolve(results);\n        } else {\n          resolve(result);\n        }\n      });\n      fn.apply(that, args);\n    });\n  };\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n  if (typeof P !== 'function') {\n    opts = P;\n    P = Promise;\n  }\n\n  opts = opts || {};\n  opts.exclude = opts.exclude || [/.+Sync$/];\n\n  var filter = function (key) {\n    var match = function (pattern) {\n      return typeof pattern === 'string' ? key === pattern : pattern.test(key);\n    };\n\n    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n  };\n\n  var ret = typeof obj === 'function' ? function () {\n    if (opts.excludeMain) {\n      return obj.apply(this, arguments);\n    }\n\n    return processFn(obj, P, opts).apply(this, arguments);\n  } : {};\n  return Object.keys(obj).reduce(function (ret, key) {\n    var x = obj[key];\n    ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n    return ret;\n  }, ret);\n};\n\npify$1.all = pify$1;\nvar pifyExports = pify$2.exports;\nvar fs = require$$0__default;\nvar path$2 = require$$0;\nvar pify = pifyExports;\nvar stat = pify(fs.stat);\nvar readFile = pify(fs.readFile);\nvar resolve = path$2.resolve;\nvar cache = Object.create(null);\n\nfunction convert(content, encoding) {\n  if (Buffer.isEncoding(encoding)) {\n    return content.toString(encoding);\n  }\n\n  return content;\n}\n\nreadCache$1.exports = function (path, encoding) {\n  path = resolve(path);\n  return stat(path).then(function (stats) {\n    var item = cache[path];\n\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n\n    return readFile(path).then(function (data) {\n      cache[path] = {\n        mtime: stats.mtime,\n        content: data\n      };\n      return convert(data, encoding);\n    });\n  }).catch(function (err) {\n    cache[path] = null;\n    return Promise.reject(err);\n  });\n};\n\nreadCache$1.exports.sync = function (path, encoding) {\n  path = resolve(path);\n\n  try {\n    var stats = fs.statSync(path);\n    var item = cache[path];\n\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n\n    var data = fs.readFileSync(path);\n    cache[path] = {\n      mtime: stats.mtime,\n      content: data\n    };\n    return convert(data, encoding);\n  } catch (err) {\n    cache[path] = null;\n    throw err;\n  }\n};\n\nreadCache$1.exports.get = function (path, encoding) {\n  path = resolve(path);\n\n  if (cache[path]) {\n    return convert(cache[path].content, encoding);\n  }\n\n  return null;\n};\n\nreadCache$1.exports.clear = function () {\n  cache = Object.create(null);\n};\n\nvar readCacheExports = readCache$1.exports;\nconst dataURLRegexp = /^data:text\\/css;base64,/i;\n\nfunction isValid(url) {\n  return dataURLRegexp.test(url);\n}\n\nfunction contents(url) {\n  // \"data:text/css;base64,\".length === 21\n  return Buffer.from(url.slice(21), \"base64\").toString();\n}\n\nvar dataUrl = {\n  isValid,\n  contents\n};\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\n\nvar loadContent$1 = filename => {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename);\n  }\n\n  return readCache(filename, \"utf-8\");\n}; // builtin tooling\n\n\nconst path$1 = require$$0; // placeholder tooling\n\nlet sugarss;\n\nvar processContent$1 = function processContent(result, content, filename, options, postcss) {\n  const {\n    plugins\n  } = options;\n  const ext = path$1.extname(filename);\n  const parserList = []; // SugarSS support:\n\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n\n    }\n\n    if (sugarss) return runPostcss(postcss, content, filename, plugins, [sugarss]);\n  } // Syntax support:\n\n\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  } // Parser support:\n\n\n  if (result.opts.parser) parserList.push(result.opts.parser); // Try the default as a last resort:\n\n  parserList.push(null);\n  return runPostcss(postcss, content, filename, plugins, parserList);\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins).process(content, {\n    from: filename,\n    parser: parsers[index]\n  }).catch(err => {\n    // If there's an error, try the next parser\n    index++; // If there are no parsers left, throw it\n\n    if (index === parsers.length) throw err;\n    return runPostcss(postcss, content, filename, plugins, parsers, index);\n  });\n} // external tooling\n\n\nconst valueParser = lib; // extended tooling\n\nconst {\n  stringify\n} = valueParser;\n\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\";\n\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\";\n    }\n\n    return item + stringify(node);\n  }, \"\");\n  list.push(last);\n  return list;\n}\n\nvar parseStatements$1 = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n  styles.each(node => {\n    let stmt;\n\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);else if (node.name === \"media\") stmt = parseMedia(result, node);else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: []\n        });\n        nodes = [];\n      }\n\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: []\n    });\n  }\n\n  return statements;\n};\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: []\n  };\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule\n    });\n  }\n\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: []\n  };\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n\n  if (prev) {\n    do {\n      if (prev.type !== \"comment\" && (prev.type !== \"atrule\" || prev.name !== \"import\" && prev.name !== \"charset\" && !(prev.name === \"layer\" && !prev.nodes))) {\n        return result.warn(\"@import must precede all other statements (besides @charset or empty @layer)\", {\n          node: atRule\n        });\n      }\n\n      prev = prev.prev();\n    } while (prev);\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\"It looks like you didn't end your @import statement correctly. \" + \"Child nodes are attached to it.\", {\n      node: atRule\n    });\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: []\n  }; // prettier-ignore\n\n  if (!params.length || (params[0].type !== \"string\" || !params[0].value) && (params[0].type !== \"function\" || params[0].value !== \"url\" || !params[0].nodes.length || !params[0].nodes[0].value)) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule\n    });\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n  let remainder = params;\n\n  if (remainder.length > 2) {\n    if ((remainder[2].type === \"word\" || remainder[2].type === \"function\") && remainder[2].value === \"layer\") {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", {\n          node: atRule\n        });\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n\n      remainder = remainder.slice(2);\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", {\n        node: atRule\n      });\n    }\n\n    stmt.media = split(remainder, 2);\n  }\n\n  return stmt;\n}\n\nvar assignLayerNames$1 = function (layer, node, state, options) {\n  layer.forEach((layerPart, i) => {\n    if (layerPart.trim() === \"\") {\n      if (options.nameLayer) {\n        layer[i] = options.nameLayer(state.anonymousLayerCounter++, state.rootFilename).toString();\n      } else {\n        throw node.error(`When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`);\n      }\n    }\n  });\n}; // builtin tooling\n\n\nconst path = require$$0; // internal tooling\n\nconst joinMedia = joinMedia$1;\nconst joinLayer = joinLayer$1;\n\nconst resolveId = id => id;\n\nconst loadContent = loadContent$1;\nconst processContent = processContent$1;\nconst parseStatements = parseStatements$1;\nconst assignLayerNames = assignLayerNames$1;\nconst dataURL = dataUrl;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options\n  };\n  options.root = path.resolve(options.root); // convert string to an array of a single element\n\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(p => path.resolve(options.root, p));\n  return {\n    postcssPlugin: \"postcss-import\",\n\n    Once(styles, {\n      result,\n      atRule,\n      postcss\n    }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0\n      };\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\");\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\");\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(bundle => {\n        applyRaws(bundle);\n        applyMedia(bundle);\n        applyStyles(bundle, styles);\n      });\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return;\n\n          if (stmt.parent) {\n            const {\n              before\n            } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (!stmt.media.length && !stmt.layer.length || stmt.type === \"charset\") {\n            return;\n          }\n\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options);\n          }\n\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri];\n            const media = stmt.media.join(\", \");\n\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\");\n              let layerParams = \"layer\";\n\n              if (layerName) {\n                layerParams = `layer(${layerName})`;\n              }\n\n              parts.push(layerParams);\n            }\n\n            if (media) {\n              parts.push(media);\n            }\n\n            stmt.node.params = parts.join(\" \");\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source\n              });\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source\n                });\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const {\n              nodes\n            } = stmt;\n            const {\n              parent\n            } = nodes[0];\n            let outerAtRule;\n            let innerAtRule;\n\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source\n              });\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source\n              });\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule); // remove nodes\n\n            nodes.forEach(node => {\n              node.parent = undefined;\n            }); // better output\n\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"; // wrap new rules with media query and/or layer at rule\n\n            innerAtRule.append(nodes);\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []; // Strip additional statements.\n\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n        return Promise.resolve(statements).then(stmts => {\n          // process each statement in series\n          return stmts.reduce((promise, stmt) => {\n            return promise.then(() => {\n              stmt.media = joinMedia(media, stmt.media || []);\n              stmt.parentMedia = media;\n              stmt.layer = joinLayer(layer, stmt.layer || []); // skip protocol base uri (protocol://url) or protocol-relative\n\n              if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n                return;\n              }\n\n              if (options.filter && !options.filter(stmt.uri)) {\n                // rejected by filter\n                return;\n              }\n\n              return resolveImportId(result, stmt, options, state);\n            });\n          }, Promise.resolve());\n        }).then(() => {\n          let charset;\n          const imports = [];\n          const bundle = [];\n\n          function handleCharset(stmt) {\n            if (!charset) charset = stmt; // charsets aren't case-sensitive, so convert to lower case to compare\n            else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {\n              throw new Error(`Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`);\n            }\n          } // squash statements and their children\n\n\n          statements.forEach(stmt => {\n            if (stmt.type === \"charset\") handleCharset(stmt);else if (stmt.type === \"import\") {\n              if (stmt.children) {\n                stmt.children.forEach((child, index) => {\n                  if (child.type === \"import\") imports.push(child);else if (child.type === \"charset\") handleCharset(child);else bundle.push(child); // For better output\n\n                  if (index === 0) child.parent = stmt;\n                });\n              } else imports.push(stmt);\n            } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n              bundle.push(stmt);\n            }\n          });\n          return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);\n        });\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(result => {\n            stmt.children = result;\n          });\n        }\n\n        const atRule = stmt.node;\n        let sourceFile;\n\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n\n        const base = sourceFile ? path.dirname(atRule.source.input.file) : options.root;\n        return Promise.resolve(options.resolve(stmt.uri, base, options)).then(paths => {\n          if (!Array.isArray(paths)) paths = [paths]; // Ensure that each path is absolute:\n\n          return Promise.all(paths.map(file => {\n            return !path.isAbsolute(file) ? resolveId(file) : file;\n          }));\n        }).then(resolved => {\n          // Add dependency messages:\n          resolved.forEach(file => {\n            result.messages.push({\n              type: \"dependency\",\n              plugin: \"postcss-import\",\n              file,\n              parent: sourceFile\n            });\n          });\n          return Promise.all(resolved.map(file => {\n            return loadImportContent(result, stmt, file, options, state);\n          }));\n        }).then(result => {\n          // Merge loaded statements\n          stmt.children = result.reduce((result, statements) => {\n            return statements ? result.concat(statements) : result;\n          }, []);\n        });\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const {\n          media,\n          layer\n        } = stmt;\n        assignLayerNames(layer, atRule, state, options);\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return;\n          } // save imported files to skip them next time\n\n\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n\n          state.importedFiles[filename][media][layer] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(content => {\n          if (content.trim() === \"\") {\n            result.warn(`${filename} is empty`, {\n              node: atRule\n            });\n            return;\n          } // skip previous imported files not containing @import rules\n\n\n          if (state.hashFiles[content]?.[media]?.[layer]) {\n            return;\n          }\n\n          return processContent(result, content, filename, options, postcss).then(importedResult => {\n            const styles = importedResult.root;\n            result.messages = result.messages.concat(importedResult.messages);\n\n            if (options.skipDuplicates) {\n              const hasImport = styles.some(child => {\n                return child.type === \"atrule\" && child.name === \"import\";\n              });\n\n              if (!hasImport) {\n                // save hash files to skip them next time\n                if (!state.hashFiles[content]) {\n                  state.hashFiles[content] = {};\n                }\n\n                if (!state.hashFiles[content][media]) {\n                  state.hashFiles[content][media] = {};\n                }\n\n                state.hashFiles[content][media][layer] = true;\n              }\n            } // recursion: import @import from imported file\n\n\n            return parseStyles(result, styles, options, state, media, layer);\n          });\n        });\n      }\n    }\n\n  };\n}\n\nAtImport.postcss = true;\nvar postcssImport = AtImport;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\n\nexport { index$1 as i };","map":{"version":3,"names":["E","getDefaultExportFromCjs","require$$0","require$$0__default","l","lib","fileURLToPath","__cjs_fileURLToPath","dirname","__cjs_dirname","createRequire","__cjs_createRequire","__filename","import","meta","url","__dirname","require","__require","_mergeNamespaces","n","m","i","length","e","Array","isArray","k","startsWithKeywordRegexp","joinMedia$1","parentMedia","childMedia","media","forEach","parentItem","parentItemStartsWithKeyword","test","childItem","childItemStartsWithKeyword","push","joinLayer$1","parentLayer","childLayer","concat","readCache$1","exports","pify$2","processFn","fn","P","opts","that","args","arguments","resolve","reject","err","result","multiArgs","results","apply","pify$1","obj","Promise","exclude","filter","key","match","pattern","include","some","ret","excludeMain","Object","keys","reduce","x","all","pifyExports","fs","path$2","pify","stat","readFile","cache","create","convert","content","encoding","Buffer","isEncoding","toString","path","then","stats","item","mtime","getTime","data","catch","sync","statSync","readFileSync","get","clear","readCacheExports","dataURLRegexp","isValid","contents","from","slice","dataUrl","readCache","dataURL$1","loadContent$1","filename","path$1","sugarss","processContent$1","processContent","options","postcss","plugins","ext","extname","parserList","runPostcss","syntax","parse","parser","parsers","index","process","valueParser","stringify","split","params","start","list","last","node","type","value","parseStatements$1","styles","statements","nodes","each","stmt","name","parseImport","parseMedia","parseCharset","layer","atRule","prev","warn","uri","fullUri","remainder","assignLayerNames$1","state","layerPart","trim","nameLayer","anonymousLayerCounter","rootFilename","error","joinMedia","joinLayer","resolveId","id","loadContent","parseStatements","assignLayerNames","dataURL","AtImport","root","cwd","skipDuplicates","load","addModulesDirectories","map","p","postcssPlugin","Once","importedFiles","hashFiles","source","input","file","Error","parseStyles","bundle","applyRaws","applyMedia","applyStyles","parent","before","raws","parts","join","layerName","layerParams","layerNode","mediaNode","append","outerAtRule","innerAtRule","insertBefore","undefined","includes","stmts","promise","resolveImportId","charset","imports","handleCharset","toLowerCase","children","child","loadImportContent","sourceFile","base","paths","isAbsolute","resolved","messages","plugin","importedResult","hasImport","postcssImport","index$1","__proto__","default"],"sources":["/Users/macbook/Desktop/afrimartCom/node_modules/vite/dist/node/chunks/dep-e0331088.js"],"sourcesContent":["import { E as getDefaultExportFromCjs } from './dep-df561101.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-c423598f.js';\n\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\n\nconst __filename = __cjs_fileURLToPath(import.meta.url);\nconst __dirname = __cjs_dirname(__filename);\nconst require = __cjs_createRequire(import.meta.url);\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nconst startsWithKeywordRegexp = /^(all|not|only|print|screen)/i;\n\nvar joinMedia$1 = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia\n  if (parentMedia.length && !childMedia.length) return parentMedia\n  if (!parentMedia.length && !childMedia.length) return []\n\n  const media = [];\n\n  parentMedia.forEach(parentItem => {\n    const parentItemStartsWithKeyword = startsWithKeywordRegexp.test(parentItem);\n\n    childMedia.forEach(childItem => {\n      const childItemStartsWithKeyword = startsWithKeywordRegexp.test(childItem);\n      if (parentItem !== childItem) {\n        if (childItemStartsWithKeyword && !parentItemStartsWithKeyword) {\n          media.push(`${childItem} and ${parentItem}`);\n        } else {\n          media.push(`${parentItem} and ${childItem}`);\n        }\n      }\n    });\n  });\n\n  return media\n};\n\nvar joinLayer$1 = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer\n  if (parentLayer.length && !childLayer.length) return parentLayer\n  if (!parentLayer.length && !childLayer.length) return []\n\n  return parentLayer.concat(childLayer)\n};\n\nvar readCache$1 = {exports: {}};\n\nvar pify$2 = {exports: {}};\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify$1.all = pify$1;\n\nvar pifyExports = pify$2.exports;\n\nvar fs = require$$0__default;\r\nvar path$2 = require$$0;\r\nvar pify = pifyExports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$2.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\n\nvar readCacheExports = readCache$1.exports;\n\nconst dataURLRegexp = /^data:text\\/css;base64,/i;\n\nfunction isValid(url) {\n  return dataURLRegexp.test(url)\n}\n\nfunction contents(url) {\n  // \"data:text/css;base64,\".length === 21\n  return Buffer.from(url.slice(21), \"base64\").toString()\n}\n\nvar dataUrl = {\n  isValid,\n  contents,\n};\n\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\n\nvar loadContent$1 = filename => {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename)\n  }\n\n  return readCache(filename, \"utf-8\")\n};\n\n// builtin tooling\nconst path$1 = require$$0;\n\n// placeholder tooling\nlet sugarss;\n\nvar processContent$1 = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss\n) {\n  const { plugins } = options;\n  const ext = path$1.extname(filename);\n\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++;\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n\n// external tooling\nconst valueParser = lib;\n\n// extended tooling\nconst { stringify } = valueParser;\n\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\");\n  list.push(last);\n  return list\n}\n\nvar parseStatements$1 = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);\n      else if (node.name === \"media\") stmt = parseMedia(result, node);\n      else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    });\n  }\n\n  return statements\n};\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev();\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  };\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;\n  else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n\n  let remainder = params;\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n      remainder = remainder.slice(2);\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2);\n  }\n\n  return stmt\n}\n\nvar assignLayerNames$1 = function (layer, node, state, options) {\n  layer.forEach((layerPart, i) => {\n    if (layerPart.trim() === \"\") {\n      if (options.nameLayer) {\n        layer[i] = options\n          .nameLayer(state.anonymousLayerCounter++, state.rootFilename)\n          .toString();\n      } else {\n        throw node.error(\n          `When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`\n        )\n      }\n    }\n  });\n};\n\n// builtin tooling\nconst path = require$$0;\n\n// internal tooling\nconst joinMedia = joinMedia$1;\nconst joinLayer = joinLayer$1;\nconst resolveId = (id) => id;\nconst loadContent = loadContent$1;\nconst processContent = processContent$1;\nconst parseStatements = parseStatements$1;\nconst assignLayerNames = assignLayerNames$1;\nconst dataURL = dataUrl;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  };\n\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n\n  if (!Array.isArray(options.path)) options.path = [];\n\n  options.path = options.path.map(p => path.resolve(options.root, p));\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      };\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle);\n          applyMedia(bundle);\n          applyStyles(bundle, styles);\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\n            else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options);\n          }\n\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri];\n\n            const media = stmt.media.join(\", \");\n\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\");\n\n              let layerParams = \"layer\";\n              if (layerName) {\n                layerParams = `layer(${layerName})`;\n              }\n\n              parts.push(layerParams);\n            }\n\n            if (media) {\n              parts.push(media);\n            }\n\n            stmt.node.params = parts.join(\" \");\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source,\n              });\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                });\n\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const { nodes } = stmt;\n            const { parent } = nodes[0];\n\n            let outerAtRule;\n            let innerAtRule;\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              });\n\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              });\n\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule);\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined;\n            });\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes);\n\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = [];\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || []);\n                stmt.parentMedia = media;\n                stmt.layer = joinLayer(layer, stmt.layer || []);\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset;\n            const imports = [];\n            const bundle = [];\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt;\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt);\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child);\n                    else if (child.type === \"charset\") handleCharset(child);\n                    else bundle.push(child);\n                    // For better output\n                    if (index === 0) child.parent = stmt;\n                  });\n                } else imports.push(stmt);\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt);\n              }\n            });\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(\n            result => {\n              stmt.children = result;\n            }\n          )\n        }\n\n        const atRule = stmt.node;\n        let sourceFile;\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root;\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths];\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              });\n            });\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, []);\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const { media, layer } = stmt;\n\n        assignLayerNames(layer, atRule, state, options);\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n          state.importedFiles[filename][media][layer] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule });\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root;\n              result.messages = result.messages.concat(importedResult.messages);\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                });\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {};\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {};\n                  }\n                  state.hashFiles[content][media][layer] = true;\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true;\n\nvar postcssImport = AtImport;\n\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\n\nexport { index$1 as i };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}