{"ast":null,"code":"'use strict';\n\nlet Declaration = require('./declaration');\n\nlet tokenizer = require('./tokenize');\n\nlet Comment = require('./comment');\n\nlet AtRule = require('./at-rule');\n\nlet Root = require('./root');\n\nlet Rule = require('./rule');\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n};\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i];\n    let pos = token[3] || token[2];\n    if (pos) return pos;\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.customProperty = false;\n    this.createTokenizer();\n    this.root.source = {\n      input,\n      start: {\n        column: 1,\n        line: 1,\n        offset: 0\n      }\n    };\n  }\n\n  atrule(token) {\n    let node = new AtRule();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2]);\n    let type;\n    let prev;\n    let shift;\n    let last = false;\n    let open = false;\n    let params = [];\n    let brackets = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      type = token[0];\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}');\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2]);\n          node.source.end.offset++;\n          this.semicolon = true;\n          break;\n        } else if (type === '{') {\n          open = true;\n          break;\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1;\n            prev = params[shift];\n\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift];\n            }\n\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2]);\n              node.source.end.offset++;\n            }\n          }\n\n          this.end(token);\n          break;\n        } else {\n          params.push(token);\n        }\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = this.getPosition(token[3] || token[2]);\n        node.source.end.offset++;\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens);\n    if (colon === false) return;\n    let founded = 0;\n    let token;\n\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    } // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n\n\n    throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n  }\n\n  colon(tokens) {\n    let brackets = 0;\n    let token, type, prev;\n\n    for (let [i, element] of tokens.entries()) {\n      token = element;\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      }\n\n      if (type === ')') {\n        brackets -= 1;\n      }\n\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  }\n\n  comment(token) {\n    let node = new Comment();\n    this.init(node, token[2]);\n    node.source.end = this.getPosition(token[3] || token[2]);\n    node.source.end.offset++;\n    let text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input);\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration();\n    this.init(node, tokens[0][2]);\n    let last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n    node.source.end.offset++;\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = this.getPosition(tokens[0][2]);\n    node.prop = '';\n\n    while (tokens.length) {\n      let type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    let token;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    let firstSpaces = [];\n    let next;\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      firstSpaces.push(tokens.shift());\n    }\n\n    this.precheckMissedSemicolon(tokens);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        let string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0);\n        let str = '';\n\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('');\n      firstSpaces = [];\n    }\n\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens);\n    }\n  }\n\n  doubleColon(token) {\n    throw this.input.error('Double colon', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n\n  emptyRule(token) {\n    let node = new Rule();\n    this.init(node, token[2]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2]);\n      this.current.source.end.offset++;\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.root.source.end = this.getPosition(this.tokenizer.position());\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  } // Helpers\n\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset);\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    };\n  }\n\n  init(node, offset) {\n    this.current.push(node);\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  }\n\n  other(start) {\n    let end = false;\n    let type = null;\n    let colon = false;\n    let bracket = null;\n    let brackets = [];\n    let customProperty = start[1].startsWith('--');\n    let tokens = [];\n    let token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token;\n        brackets.push('}');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0];\n          if (token !== 'space' && token !== 'comment') break;\n          this.tokenizer.back(tokens.pop());\n        }\n      }\n\n      this.decl(tokens, customProperty);\n    } else {\n      this.unknownWord(tokens);\n    }\n  }\n\n  parse() {\n    let token;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  }\n\n  precheckMissedSemicolon() {// Hook for Safe Parser\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type;\n    let length = tokens.length;\n    let value = '';\n    let clean = true;\n    let next, prev;\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false;\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false;\n          } else {\n            value += token[1];\n          }\n        } else {\n          clean = false;\n        }\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '');\n      node.raws[prop] = {\n        raw,\n        value\n      };\n    }\n\n    node[prop] = value;\n  }\n\n  rule(tokens) {\n    tokens.pop();\n    let node = new Rule();\n    this.init(node, tokens[0][2]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  } // Errors\n\n\n  spacesAndCommentsFromStart(tokens) {\n    let next;\n    let spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  }\n\n  stringFrom(tokens, from) {\n    let result = '';\n\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  }\n\n  unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', {\n      offset: bracket[2]\n    }, {\n      offset: bracket[2] + 1\n    });\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error('Unexpected }', {\n      offset: token[2]\n    }, {\n      offset: token[2] + 1\n    });\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error('Unknown word', {\n      offset: tokens[0][2]\n    }, {\n      offset: tokens[0][2] + tokens[0][1].length\n    });\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"names":["Declaration","require","tokenizer","Comment","AtRule","Root","Rule","SAFE_COMMENT_NEIGHBOR","empty","space","findLastWithPosition","tokens","i","length","token","pos","Parser","constructor","input","root","current","spaces","semicolon","customProperty","createTokenizer","source","start","column","line","offset","atrule","node","name","slice","unnamedAtrule","init","type","prev","shift","last","open","params","brackets","endOfFile","nextToken","push","pop","end","getPosition","raws","between","spacesAndCommentsFromEnd","afterName","spacesAndCommentsFromStart","raw","nodes","checkMissedSemicolon","colon","founded","j","error","element","entries","doubleColon","comment","text","test","left","right","match","decl","unknownWord","before","prop","firstSpaces","next","precheckMissedSemicolon","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","trim","indexOf","hasWord","some","map","join","concat","value","includes","emptyRule","selector","after","parent","unexpectedClose","endFile","unclosedBlock","position","freeSemicolon","ownSemicolon","fromOffset","col","other","bracket","startsWith","rule","back","unclosedBracket","parse","clean","reduce","all","lastTokenType","from","result","splice","module","exports"],"sources":["/Users/macbook/Desktop/afrimartCom/node_modules/postcss/lib/parser.js"],"sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          node.source.end.offset++\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n              node.source.end.offset++\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        node.source.end.offset++\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n    node.source.end.offset++\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n    node.source.end.offset++\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current.source.end.offset++\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.root.source.end = this.getPosition(this.tokenizer.position())\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { raw, value }\n    }\n    node[prop] = value\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  // Errors\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}