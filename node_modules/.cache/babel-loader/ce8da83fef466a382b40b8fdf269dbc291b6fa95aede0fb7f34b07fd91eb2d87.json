{"ast":null,"code":"/*\n  @license\n\tRollup.js v3.29.3\n\tSun, 24 Sep 2023 05:31:36 GMT - commit 353e4628284b1ef4d8a8b47d895881e5ce6546f4\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'tty';\nvar chokidar = {};\nconst fs$3 = require$$0$1;\nconst {\n  Readable\n} = require$$1;\nconst sysPath$3 = require$$0$2;\nconst {\n  promisify: promisify$3\n} = require$$2;\nconst picomatch$1 = picomatch$2;\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat$2 : stat$3; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = {\n        path: sysPath$3.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\nvar readdirp_1 = readdirp$1;\nvar anymatch$2 = {\n  exports: {}\n};\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\n  var prefix = '';\n\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n\n  return prefix + segs.join('/');\n};\n\nvar anymatch_1 = anymatch$2.exports;\nObject.defineProperty(anymatch_1, \"__esModule\", {\n  value: true\n});\nconst picomatch = picomatch$2;\nconst normalizePath$1 = normalizePath$2;\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nconst arrify$1 = item => Array.isArray(item) ? item : [item];\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n\n  return string => false;\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n\n  const _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  const path = normalizePath$1(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG$1).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1).map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\nvar anymatchExports = anymatch$2.exports;\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isExtglob = isExtglob$1;\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\n\nvar strictCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar relaxedCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck; // optionally relax check\n\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\n\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts); // flip windows path separators\n\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  } // special case for strings ending in enclosure containing path separator\n\n\n  if (enclosure.test(str)) {\n    str += slash;\n  } // preserves full path in case of trailing path separator\n\n\n  str += 'a'; // remove path parts that are globby\n\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str)); // remove escape chars and return result\n\n\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = (min, max, step = 1, limit) => {\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = (block, n = 0, type) => {\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = (...args) => {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    flat(args);\n    return result;\n  };\n})(utils$3);\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber$2 = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange$1.cache = {};\n\ntoRegexRange$1.clearCache = () => toRegexRange$1.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange$1;\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options,\n        wrap: false,\n        toRegex: true\n      });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n\n  /* 0 */\n  CHAR_9: '9',\n\n  /* 9 */\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n\n  /* z */\n  CHAR_LEFT_PARENTHESES: '(',\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n\n  /* ) */\n  CHAR_ASTERISK: '*',\n\n  /* * */\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n\n  /* & */\n  CHAR_AT: '@',\n\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n\n  /* \\ */\n  CHAR_BACKTICK: '`',\n\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n\n  /* ^ */\n  CHAR_COLON: ':',\n\n  /* : */\n  CHAR_COMMA: ',',\n\n  /* , */\n  CHAR_DOLLAR: '$',\n\n  /* . */\n  CHAR_DOT: '.',\n\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n\n  /* \" */\n  CHAR_EQUAL: '=',\n\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n\n  /* / */\n  CHAR_HASH: '#',\n\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n\n  /* % */\n  CHAR_PLUS: '+',\n\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n\n  /* ] */\n  CHAR_SEMICOLON: ';',\n\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n\n  /* ' */\n  CHAR_SPACE: ' ',\n\n  /*   */\n  CHAR_TAB: '\\t',\n\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\nconst stringify$1 = stringify$4;\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify$1(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1 = parse$1;\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  return compile(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces$1;\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\nvar binaryExtensions$1 = require$$0;\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1;\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n  const {\n    sep\n  } = require$$0$2;\n  const {\n    platform\n  } = process;\n  const os = require$$2$1;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n\n  exports.EMPTY_FN = () => {};\n\n  exports.IDENTITY_FN = val => val;\n\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n  exports.isIBMi = os.type() === 'OS400';\n})(constants);\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst {\n  promisify: promisify$2\n} = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\nconst statMethods$1 = {\n  lstat: lstat$1,\n  stat: stat$2\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n/**\n * @typedef {String} Path\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\n\n\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\n\n\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\n\n\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  let watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\n\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  const copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE$2, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\n * @mixin\n */\n\n\nlet NodeFsHandler$1 = class NodeFsHandler {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath$2.dirname(path);\n    const basename = sysPath$2.basename(path);\n\n    const parent = this.fsw._getWatchedDir(directory);\n\n    parent.add(basename);\n    const absolutePath = sysPath$2.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN$2;\n    let closer;\n\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const dirname = sysPath$2.dirname(file);\n    const basename = sysPath$2.basename(file);\n\n    const parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n    let prevStats = stats; // if the file is already being watched, do nothing\n\n    if (parent.has(basename)) return;\n\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$2(file);\n          if (this.fsw.closed) return; // Check that change event was not fired because of changed only accessTime.\n\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE$2, file, newStats);\n          }\n\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n\n            prevStats = newStats;\n\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        } // add is about to be emitted if file not already tracked in parent\n\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n\n        prevStats = newStats;\n      }\n    }; // kick off the watcher\n\n\n    const closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n\n      this.fsw._emit(EV_ADD$2, file, stats);\n    }\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n\n\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const full = entry.fullPath;\n\n    const dir = this.fsw._getWatchedDir(directory);\n\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n\n      let linkPath;\n\n      try {\n        linkPath = await fsrealpath(path);\n      } catch (e) {\n        this.fsw._emitReady();\n\n        return true;\n      }\n\n      if (this.fsw.closed) return;\n\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n\n          this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n\n        this.fsw._symlinkPaths.set(full, linkPath);\n\n        this.fsw._emit(EV_ADD$2, path, entry.stats);\n      }\n\n      this.fsw._emitReady();\n\n      return true;\n    } // don't follow the same symlink more than once\n\n\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n\n    this.fsw._symlinkPaths.set(full, true);\n  }\n\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    const previous = this.fsw._getWatchedDir(wh.path);\n\n    const current = new Set();\n\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA$1, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const item = entry.path;\n      let path = sysPath$2.join(directory, item);\n      current.add(item);\n\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      } // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n        path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR$2, this._boundHandleError);\n\n    return new Promise(resolve => stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath$2.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n\n\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n\n    const tracked = parentDir.has(sysPath$2.basename(dir));\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n    } // ensure dir is tracked (harmless if redundant)\n\n\n    parentDir.add(sysPath$2.basename(dir));\n\n    this.fsw._getWatchedDir(dir);\n\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n\n\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n\n    const wh = this.fsw._getWatchHelpers(path, depth);\n\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n\n      wh.filterPath = entry => priorWh.filterPath(entry);\n\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    } // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n      let closer;\n\n      if (stats.isDirectory()) {\n        const absPath = sysPath$2.resolve(path);\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (absPath !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(absPath, targetPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath$2.dirname(wh.watchPath);\n\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n\n      ready();\n\n      this.fsw._addPathCloser(path, closer);\n\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n\n};\nvar nodefsHandler = NodeFsHandler$1;\nvar fseventsHandler = {\n  exports: {}\n};\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst {\n  promisify: promisify$1\n} = require$$2;\nlet fsevents;\n\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\nconst statMethods = {\n  stat: stat$1,\n  lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\n * @mixin\n */\n\n\nlet FsEventsHandler$1 = class FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$1(path);\n      if (this.fsw.closed) return;\n\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK$1) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath$1.dirname(path);\n      const item = sysPath$1.basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE$1) {\n          let stats;\n\n          try {\n            stats = await stat$1(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath$1.join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n\n    const base = sysPath$1.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE$1) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n};\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\nvar fseventsHandlerExports = fseventsHandler.exports;\nconst {\n  EventEmitter\n} = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst {\n  promisify\n} = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\n\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => path => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n  /**\n   * @returns {Array<String>}\n   */\n\n\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\n\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    super();\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    this._closers = new Map();\n    /** @type {Set<String>} */\n\n    this._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    this._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n\n    this._emitReady = () => {\n      readyCalls++;\n\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n\n    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n\n    this._readyEmitted = false;\n    this.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    } // Youre frozen when your hearts not open.\n\n\n    Object.freeze(opts);\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n\n        return normalizePath(absPath);\n      });\n    } // set aside negated glob strings\n\n\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n\n        return false;\n      } // if a path is being added that was previously ignored, stop ignoring it\n\n\n      this._ignoredPaths.delete(path);\n\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n      return true;\n    });\n\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n\n\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n\n      this._closePath(path);\n\n      this._ignoredPaths.add(path);\n\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      } // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n\n\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true; // Memory management.\n\n    this.removeAllListeners();\n    const closers = [];\n\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n\n    this._streams.forEach(stream => stream.destroy());\n\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n\n    this._watched.forEach(dirent => dirent.dispose());\n\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n\n\n  getWatched() {\n    const watchList = {};\n\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n\n    return watchList;\n  }\n\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  } // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n\n        this._pendingUnlinks.delete(path);\n      }\n    }\n\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n\n          this.emitWithAll(event, args);\n        }\n      };\n\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n      return this;\n    }\n\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {} // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\n\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n\n    this.emitWithAll(event, args);\n    return this;\n  }\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  _handleError(error) {\n    const code = error && error.code;\n\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n\n    return error || this.closed;\n  }\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n\n\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n    /** @type {Map<Path, Object>} */\n\n\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n\n\n    const actionPath = action.get(path);\n\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n\n    let timeoutObject;\n\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n\n\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n\n    const now = new Date();\n\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n\n        const now = Number(new Date());\n\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n\n        const pw = this._pendingWrites.get(path);\n\n        const df = now - pw.lastChange;\n\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n\n\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n\n    return this._userIgnored([path, stats]);\n  }\n\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n\n\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  } // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n\n\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  } // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n\n\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n\n\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n\n    if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    } // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n\n\n    const wp = this._getWatchedDir(path);\n\n    const nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested)); // Check if item was on the watched list and remove it\n\n    const parent = this._getWatchedDir(directory);\n\n    const wasTracked = parent.has(item);\n    parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    } // If we wait for this file to be fully written, cancel the wait.\n\n\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n\n      if (event === EV_ADD) return;\n    } // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n\n\n    this._watched.delete(path);\n\n    this._watched.delete(fullPath);\n\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n\n\n  _closePath(path) {\n    this._closeFile(path);\n\n    const dir = sysPath.dirname(path);\n\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n\n\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n\n    if (!closers) return;\n    closers.forEach(closer => closer());\n\n    this._closers.delete(path);\n  }\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n\n\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n\n    let list = this._closers.get(path);\n\n    if (!list) {\n      list = [];\n\n      this._closers.set(path, list);\n    }\n\n    list.push(closer);\n  }\n\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n\n    this._streams.add(stream);\n\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n\n} // Export FSWatcher class\n\n\nchokidar.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n\n  close() {\n    this.watcher.close();\n\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n\n  watch(id, isTransformDependency) {\n    if (isTransformDependency) {\n      const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = platform() === 'linux';\n    const isTransformDependency = transformWatcherId !== null;\n\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n\n      if (isLinux) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n\n    const watcher = chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n\n}\n\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\n\nclass Watcher {\n  constructor(optionsList, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.closed = false;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = optionsList.map(options => new Task(this, options));\n\n    for (const {\n      watch\n    } of optionsList) {\n      if (watch && typeof watch.buildDelay === 'number') {\n        this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n      }\n    }\n\n    process$1.nextTick(() => this.run());\n  }\n\n  async close() {\n    if (this.closed) return;\n    this.closed = true;\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n\n    for (const task of this.tasks) {\n      task.close();\n    }\n\n    await this.emitter.emit('close');\n    this.emitter.removeAllListeners();\n  }\n\n  invalidate(file) {\n    if (file) {\n      const previousEvent = this.invalidatedIds.get(file.id);\n      const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n\n      try {\n        await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, {\n          event\n        })));\n        this.invalidatedIds.clear();\n        await this.emitter.emit('restart');\n        this.emitter.removeListenersForCurrentRun();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        await this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        await this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n\n  async run() {\n    this.running = true;\n    await this.emitter.emit('event', {\n      code: 'START'\n    });\n\n    for (const task of this.tasks) {\n      await task.run();\n    }\n\n    this.running = false;\n    await this.emitter.emit('event', {\n      code: 'END'\n    });\n\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n\n}\n\nclass Task {\n  constructor(watcher, options) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.options = options;\n    this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = this.options.watch || {};\n    this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, { ...watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n\n  invalidate(id, details) {\n    this.invalidated = true;\n\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue; // effective invalidation\n\n        module.originalCode = null;\n      }\n    }\n\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n  }\n\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = { ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    await this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n\n    try {\n      result = await rollupInternal(options, this.watcher.emitter);\n\n      if (this.closed) {\n        return;\n      }\n\n      this.updateWatchedFiles(result);\n      this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n      await this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n\n      await this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n\n  watchFile(id, isTransformDependency = false) {\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n\n    if (this.outputFiles.includes(id)) {\n      throw new Error('Cannot import the generated bundle');\n    } // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n\n\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n\n}\n\nexport { Task, Watcher };","map":{"version":3,"names":["resolve","process$1","picomatch","picomatch$2","getAugmentedNamespace","fseventsImporter","createFilter","rollupInternal","platform","require$$0$1","require$$2","require$$1","require$$0$2","require$$2$1","require$$0$3","chokidar","fs$3","Readable","sysPath$3","promisify","promisify$3","picomatch$1","readdir$1","readdir","stat$3","stat","lstat$2","lstat","realpath$1","realpath","BANG$2","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp$1","TypeError","readdirpPromise","reject","on","promise","default","readdirp_1","anymatch$2","exports","normalizePath$2","stripTrailing","prefix","ch","segs","anymatch_1","Object","defineProperty","value","normalizePath$1","BANG$1","DEFAULT_OPTIONS","returnIndex","arrify$1","createPattern","matcher","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","prototype","toString","call","index","nglob","applied","concat","pattern","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","anymatchExports","isExtglob$1","isExtglob","str","match","exec","chars","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","indexOf","open","close","relaxedCheck","isGlob$2","isGlob","check","strict","isGlob$1","pathPosixDirname","posix","dirname","isWin32","slash","backslash","enclosure","globby","escaped","globParent$1","globParent","assign","flipBackslashes","replace","utils$3","isInteger","num","find","nodes","exceedsLimit","max","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","reduce","acc","flatten","result","flat","arr","i","ele","utils$2","stringify$4","ast","stringify","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber$2","isFinite","isNumber$1","toRegexRange$1","String","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","sort","compare","rangeToPattern","start","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","contains","key","val","repeat","integer","pow","diff","clearCache","toRegexRange_1","util","toRegexRange","isObject","transform","toNumber","isValidValue","isNumber","input","stringify$3","end","pad","maxLength","dash","padStart","toMaxLen","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fill$2","fillRange","fill$1","utils$1","compile$1","walk","isOpen","isClose","compile_1","fill","stringify$2","utils","append","queue","stash","enclose","expand$1","rangeLimit","p","q","expand_1","constants$1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stringify$1","parse$1","SyntaxError","stack","brackets","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","forEach","parse_1","compile","expand","parse","braces$1","create","nodupes","noempty","Boolean","braces_1","require$$0","binaryExtensions$1","binaryExtensions","extensions","isBinaryPath$1","filePath","extname","toLowerCase","constants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","STAR","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","dot","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isWindows","isMacos","isLinux","isIBMi","fs$2","sysPath$2","promisify$2","isBinaryPath","isWindows$1","EMPTY_FN$2","EMPTY_STR$1","EV_CHANGE$2","EV_ADD$2","EV_ADD_DIR$2","EV_ERROR$2","STR_DATA$1","STR_END$2","BRACE_START$1","THROTTLE_MODE_WATCH","stat$2","lstat$1","fsrealpath","statMethods$1","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","watch","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler$1","NodeFsHandler","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","nodefsHandler","fseventsHandler","require$$3","fs$1","sysPath$1","promisify$1","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_UNLINK$1","EV_ERROR$1","STR_END$1","FUNCTION_TYPE$1","EMPTY_FN$1","Depth","isNaN","stat$1","statMethods","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","flags","info","watchedParent","keys","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler$1","FsEventsHandler","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","initWatch","priorDepth","joinedPath","fseventsHandlerExports","EventEmitter","fs","sysPath","readdirp","anymatch","braces","normalizePath","arrify","unifyPaths","paths_","paths","every","normalizePathToUnix","toUnix","prepend","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","globstar","unmatchedGlob","part","FSWatcher","_opts","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","id","transformWatcher","isTransformDependency","transformWatcherId","handleChange","changedId","invalidate","eventsRewrites","update","Watcher","optionsList","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","tasks","Task","run","previousEvent","removeListenersForCurrentRun","modules","watchFiles","invalidated","watched","skipWrite","outputs","outputFiles","watchOptions","include","exclude","fileWatcher","details","module","transformDependencies","originalCode","updateWatchedFiles","write","duration","previouslyWatched","depId"],"sources":["/Users/macbook/Desktop/afrimartCom/node_modules/vite/node_modules/rollup/dist/es/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v3.29.3\n\tSun, 24 Sep 2023 05:31:36 GMT - commit 353e4628284b1ef4d8a8b47d895881e5ce6546f4\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'tty';\n\nvar chokidar = {};\n\nconst fs$3 = require$$0$1;\nconst { Readable } = require$$1;\nconst sysPath$3 = require$$0$2;\nconst { promisify: promisify$3 } = require$$2;\nconst picomatch$1 = picomatch$2;\n\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = ('Dirent' in fs$3) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\n\nvar readdirp_1 = readdirp$1;\n\nvar anymatch$2 = {exports: {}};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nvar anymatch_1 = anymatch$2.exports;\n\nObject.defineProperty(anymatch_1, \"__esModule\", { value: true });\n\nconst picomatch = picomatch$2;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify$1 = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath$1(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\nvar anymatchExports = anymatch$2.exports;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n\n\texports.isInteger = num => {\n\t  if (typeof num === 'number') {\n\t    return Number.isInteger(num);\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isInteger(Number(num));\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t  if (limit === false) return false;\n\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t};\n\n\t/**\n\t * Escape the given node with '\\\\' before node.value\n\t */\n\n\texports.escapeNode = (block, n = 0, type) => {\n\t  let node = block.nodes[n];\n\t  if (!node) return;\n\n\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t    if (node.escaped !== true) {\n\t      node.value = '\\\\' + node.value;\n\t      node.escaped = true;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Returns true if the given brace node should be enclosed in literal braces\n\t */\n\n\texports.encloseBrace = node => {\n\t  if (node.type !== 'brace') return false;\n\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t    node.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a brace node is invalid.\n\t */\n\n\texports.isInvalidBrace = block => {\n\t  if (block.type !== 'brace') return false;\n\t  if (block.invalid === true || block.dollar) return true;\n\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  if (block.open !== true || block.close !== true) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a node is an open or close node\n\t */\n\n\texports.isOpenOrClose = node => {\n\t  if (node.type === 'open' || node.type === 'close') {\n\t    return true;\n\t  }\n\t  return node.open === true || node.close === true;\n\t};\n\n\t/**\n\t * Reduce an array of text nodes.\n\t */\n\n\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t  if (node.type === 'text') acc.push(node.value);\n\t  if (node.type === 'range') node.type = 'text';\n\t  return acc;\n\t}, []);\n\n\t/**\n\t * Flatten an array\n\t */\n\n\texports.flatten = (...args) => {\n\t  const result = [];\n\t  const flat = arr => {\n\t    for (let i = 0; i < arr.length; i++) {\n\t      let ele = arr[i];\n\t      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n\t    }\n\t    return result;\n\t  };\n\t  flat(args);\n\t  return result;\n\t}; \n} (utils$3));\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\n\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\n\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify$1(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse$1;\n\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces$1.compile(input, options)\n    : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\nvar binaryExtensions$1 = require$$0;\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1;\n\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n\n\tconst {sep} = require$$0$2;\n\tconst {platform} = process;\n\tconst os = require$$2$1;\n\n\texports.EV_ALL = 'all';\n\texports.EV_READY = 'ready';\n\texports.EV_ADD = 'add';\n\texports.EV_CHANGE = 'change';\n\texports.EV_ADD_DIR = 'addDir';\n\texports.EV_UNLINK = 'unlink';\n\texports.EV_UNLINK_DIR = 'unlinkDir';\n\texports.EV_RAW = 'raw';\n\texports.EV_ERROR = 'error';\n\n\texports.STR_DATA = 'data';\n\texports.STR_END = 'end';\n\texports.STR_CLOSE = 'close';\n\n\texports.FSEVENT_CREATED = 'created';\n\texports.FSEVENT_MODIFIED = 'modified';\n\texports.FSEVENT_DELETED = 'deleted';\n\texports.FSEVENT_MOVED = 'moved';\n\texports.FSEVENT_CLONED = 'cloned';\n\texports.FSEVENT_UNKNOWN = 'unknown';\n\texports.FSEVENT_TYPE_FILE = 'file';\n\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\texports.KEY_LISTENERS = 'listeners';\n\texports.KEY_ERR = 'errHandlers';\n\texports.KEY_RAW = 'rawEmitters';\n\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\texports.DOT_SLASH = `.${sep}`;\n\n\texports.BACK_SLASH_RE = /\\\\/g;\n\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\texports.SLASH = '/';\n\texports.SLASH_SLASH = '//';\n\texports.BRACE_START = '{';\n\texports.BANG = '!';\n\texports.ONE_DOT = '.';\n\texports.TWO_DOTS = '..';\n\texports.STAR = '*';\n\texports.GLOBSTAR = '**';\n\texports.ROOT_GLOBSTAR = '/**/*';\n\texports.SLASH_GLOBSTAR = '/**';\n\texports.DIR_SUFFIX = 'Dir';\n\texports.ANYMATCH_OPTS = {dot: true};\n\texports.STRING_TYPE = 'string';\n\texports.FUNCTION_TYPE = 'function';\n\texports.EMPTY_STR = '';\n\texports.EMPTY_FN = () => {};\n\texports.IDENTITY_FN = val => val;\n\n\texports.isWindows = platform === 'win32';\n\texports.isMacos = platform === 'darwin';\n\texports.isLinux = platform === 'linux';\n\texports.isIBMi = os.type() === 'OS400'; \n} (constants));\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst { promisify: promisify$2 } = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\n\nconst statMethods$1 = { lstat: lstat$1, stat: stat$2 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nlet NodeFsHandler$1 = class NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath$2.dirname(path);\n  const basename = sysPath$2.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath$2.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN$2;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath$2.dirname(file);\n  const basename = sysPath$2.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$2(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path);\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE$2, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  };\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n    this.fsw._emit(EV_ADD$2, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD$2, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA$1, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath$2.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR$2, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath$2.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n  const tracked = parentDir.has(sysPath$2.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath$2.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath$2.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath$2.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n};\n\nvar nodefsHandler = NodeFsHandler$1;\n\nvar fseventsHandler = {exports: {}};\n\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\n\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst { promisify: promisify$1 } = require$$2;\n\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\n\nconst statMethods = { stat: stat$1, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath$1.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nlet FsEventsHandler$1 = class FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$1(path);\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK$1) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath$1.join(\n      watchPath, sysPath$1.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath$1.dirname(path);\n    const item = sysPath$1.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE$1) {\n        let stats;\n        try {\n          stats = await stat$1(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath$1.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n  const base = sysPath$1.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath$1.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE$1) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n};\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\n\nvar fseventsHandlerExports = fseventsHandler.exports;\n\nconst { EventEmitter } = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst { promisify } = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\n\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // Youre frozen when your hearts not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        if (isTransformDependency) {\n            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null,\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(optionsList, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.closed = false;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = optionsList.map(options => new Task(this, options));\n        for (const { watch } of optionsList) {\n            if (watch && typeof watch.buildDelay === 'number') {\n                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n            }\n        }\n        process$1.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emit('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const previousEvent = this.invalidatedIds.get(file.id);\n            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));\n                this.invalidatedIds.clear();\n                await this.emitter.emit('restart');\n                this.emitter.removeListenersForCurrentRun();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                await this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                await this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        await this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        await this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, options) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.options = options;\n        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        await this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            await this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            await this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.includes(id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}